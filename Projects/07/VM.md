虚拟机翻译器VM
    是一个栈式虚拟机

作用：将中间虚拟代码翻译为目标机器汇编代码

栈 + 虚拟内存段

虚拟机中间代码：
   1.算术逻辑 add

   2.内存访问 push segement index 
    如：push local 2

   代码例子：
    //x + 7
    push x
    push 7
    add

    //add
    弹出栈顶俩个元素
    进行加法运算
    将结果入栈
    
    3.分支（标签与跳转）
    label label:

    goto label:

    if-goto label: 
        弹出栈顶的值，if True ，跳转

    4.函数
        (1)定义 function f nVars:

        (2)调用 call f nArgs:
            1.将函数返回地址入栈
            2.将原指针状态（寄存器）入栈
            3.修改指针
                arg指针->访问函数自身的参数
                lcl指针->访问函数自身的局部变量
            4.跳转到函数位置
        (3)返回 return:
            1.保存返回地址
            2.保存返回值
            2.恢复指针
            3.跳转回返回地址

        (4)函数调用时的栈状况:
            
Q1:
代码的误解:
//修改指针
@SP       // 1. @SP读取SP寄存器的值，即访问堆栈指针
M=M-1     // 2. SP减1，指向栈顶元素y

// 移动指针后，读取栈中所需值
A=M       // 3. 将地址设为SP当前值
D=M       // 4. 将y的值存入D寄存器 (D = y)

@SP       // 5. 再次访问堆栈指针
M=M-1     // 6. SP再减1，指向下一个元素x
A=M       // 7. 将地址设为新的SP值
M=M+D     // 8. 执行加法：M = x + y (内存位置直接更新)

@SP       // 9. 再次访问堆栈指针
M=M+1     // 10. SP加1，指向结果上方   

解：
1. M寄存的误解
当使用 M寄存器时，其索引地址默认就是当前 A寄存器的值​​。(M寄存器的本质不是一个物理寄存器，而是一个指向内存的别名，即A寄存器所指向的内存单元) 
    
2. SP是一个寄存器,存储栈指针(@SP是获取存储在SP中的指针值)

3. M = M - 1
代码中 M 指向的是 RAM[0] ，即SP中存储的值。此代码的作用是 RAM[0] = RAM[0]- 1,即SP--。

 Q2: 静态段
